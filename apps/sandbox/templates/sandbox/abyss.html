{% extends 'sandbox/base.html' %}
{% load static %}
{% block styles %}
<style>
 body {
   padding: 0 2em 2em;
   font-family: sans-serif;
 }

 article {
   width: 100%;
   background-color: rgba(0, 0, 0, 0.05);
   border: 1px solid transparent;
 }

 article:focus {
   outline: 0;
   border: 1px solid rgba(0, 0, 255, 0.25);
   box-shadow: 0 0 5px rgba(0, 0, 255, 0.25);
   background-color: rgba(0, 0, 255, 0.05);
 }

 li {
   // margin-bottom: 0.25em;
 }

 textarea {
   width: 100%;
   height: 120px;
 }

 span,
 mark {
   background-color: rgba(0, 255, 0, 0.25);
 }

 span.active {
   background-color: rgba(255, 0, 0, 0.25);
 }

 span:before {
   display: inline;
   content: '_';
   color: transparent;
   background-color: rgba(0, 0, 0, 0.5);
 }

 .debug {
   margin: 5px 0;
   background-color: rgba(0, 0, 0, 0.05);
 }

 .state {
   background-color: rgba(0, 0, 0, 0.25);
 }

 .state.enabled {
   background-color: rgba(0, 255, 0, 0.25);
 }

 .state.disabled {
   background-color: rgba(255, 0, 0, 0.25);
 }

 br[type="_moz"] {
   // display: none;
 }

 .hidden {
   display: none;
 }

 .main {
   display: flex;
   flex-flow: row;
 }

 .example,
 .info {
   padding: 0.5em;
   width: 50%;
 }

</style>
{% endblock %}
{% block content %}
<main class="main">
  <section class="example">
    <article class="js-abyss" contenteditable spellcheck="false" autocomplete="false" autocapitalize="false">Lorem ipsum <span class="span">dolor <span class="span">sit</span> amet</span>, <span class="span"><span>consetetur</span> sadipscing</span> elitr, sed <span class="span">diam <span class="span">nonumy eirmod</span></span> tempor invidunt ut labore et dolore magna aliquyam erat, sed diam v<span>olup</span>tua. At vero eos et a<span>cc<span>us</span>am</span> et justo duo dolores et ea rebum. Stet clita kasd gubergren, <span>no sea ta</span><span>kimata</span> sanctus est Lorem ipsum dolor sit amet.</article>
  </section>
  <section class="info">
    <div class="debug js-debug">&nbsp;</div>
    <textarea class="js-textarea"></textarea>
    <textarea class="js-log"></textarea>
    <button class="js-offset">offset = 0</button>
  </section>
</main>
{% endblock %}
{% block scripts %}
<script src="{% static 'sandbox' %}/js/polyfills/array-from-polyfill.js"></script>
<script>

 // NOTE: this is the strategy: chrome's behavior is weird. so, fix it by inserting zero width non-breaking character with spans. then make firefox behave like chrome by overriding keydown event.

 // TODO: handle caret position on click, [*|abcd] -> [|*abcd], [abcd]*| -> [abcd*]| using document.caretPositionFromPoint
 // TODO: handle selections correctly in firefox
 // TODO: highlight active thingies based on selection
 // TODO: protect feff from Backspace, Delete

 // var SPACE = '\uff5c';
 var SPACE = '|';

 window.onload = function (evt) {

   var abyss = document.querySelector('.js-abyss');
   var textArea = document.querySelector('.js-textarea');
   var debug = document.querySelector('.js-debug');
   var logger = document.querySelector('.js-log');
   var button = document.querySelector('.js-offset');

   function insert (character) {

     /*
        fix chrome caret positioning behavior by inserting special character, e.g. zero width non-breaking space

        insert character at ... at offset 0 of span and at position immediately following the span. if there is no text element at this position, create it.
      */

     var span;
     var spans = document.querySelectorAll('[contenteditable] span');
     for (var index = 0; index < spans.length; index++) {

       span = spans.item(index);

       if (span.firstChild.nodeName === '#text')
         span.firstChild.nodeValue = character + span.firstChild.nodeValue;
       else
         span.insertBefore(document.createTextNode(character), span.firstChild);
       if (span.nextSibling) {
         if (span.nextSibling.nodeName === '#text')
           span.nextSibling.nodeValue = character + span.nextSibling.nodeValue;
         else
           span.parentNode.insertBefore(document.createTextNode(character), span.nextSibling);
       }
       else {
         span.parentNode.appendChild(document.createTextNode(character));
       }
     }
   }

   insert(SPACE);

   var focusNode;
   button.onmousedown = function () {
     focusNode = document.activeElement;
   };
   button.onmouseup = function () {
     if (focusNode instanceof HTMLElement)
       focusNode.focus();
   };

   function moveToStart () {
     var s = window.getSelection();
     var r = s.getRangeAt(0);

     var node = r.startContainer;

     r.setStart(node, 0);
     r.setEnd(node, 0);

     // r.selectNode(node);
     // r.collapse(true);

   }

   button.onclick = function (evt) {
     evt.preventDefault();

     moveToStart();

     var s = window.getSelection();
     var r = s.getRangeAt(0);
     after = {
       path: findPath(r.startContainer),
       node: r.startContainer.nodeName,
       offset: r.startOffset,
     };
     debug.textContent = JSON.stringify({
       before: before,
       after: after
     }, null, 1);

   };

   abyss.addEventListener('input', update, false);
   textArea.addEventListener('input', otherUpdate, false);

   update();

   function update () {
     var text = abyss.outerHTML;
     var FEFF = String.fromCharCode(0x0feff);
     textArea.value = text.replace(/[\ufeff]/g, '&#xfeff;');
   }

   function otherUpdate () {
     abyss.outerHTML = textArea.value;
   }

   abyss.addEventListener('paste', gulp, false);
   abyss.addEventListener('cut', gulp, false);
   abyss.addEventListener('copy', gulp, false);

   function gulp (evt) {
     evt.preventDefault();
     if (evt.cancelable)
       evt.stopPropagation();
   }

   var before;

   function findPath (node) {

     if (node === null)
       return null;
     var path = [];

     while (node !== abyss && node !== null) {
       path.push(node.nodeName);
       node = node.parentNode;
     }
     return path.join('.');
   }

   var abyss = document.querySelector('.js-abyss');

   function log (evt) {
     var s = window.getSelection();
     var r = s.getRangeAt(0);
     var message = [
       evt.type + ':',
       r.startContainer.nodeName,
       r.startOffset
     ].join(' ');
     logger.value = message + '\n' + logger.value;
   }

   abyss.addEventListener('keypress', log, false);
   abyss.addEventListener('keyup', log, false);
   abyss.addEventListener('keydown', log, false);
   abyss.addEventListener('mousedown', log, false);
   abyss.addEventListener('mouseup', log, false);
   abyss.addEventListener('click', log, false);
   document.addEventListener('selectionchange', log, false);

   abyss.addEventListener('keydown', function (evt) {

     var s = window.getSelection();
     var r = s.getRangeAt(0);

     before = {
       path: findPath(r.startContainer),
       node: r.startContainer.nodeName,
       offset: r.startOffset,
     };

     // FIXME: handle selections, i.e. set send of selection as well

     // NOTE: firefox only
     // FIXME: does not work with ie11
     if (evt.key === 'ArrowRight' || evt.key === 'Right')
       if (s.focusOffset === s.focusNode.nodeValue.length)
         if (s.focusNode.nextSibling)
           if (s.focusNode.nextSibling.nodeName === 'SPAN') {
             // abcd*[|abcd] -> abcd[|*abcd]
             // NOTE: set position to zero, keydown arrow right gets applied in addition to that
             r.setStart(s.focusNode.nextSibling.childNodes[0], 0);


             // NOTE: use this for ie11
             // r.setStart(s.focusNode.nextSibling.childNodes[0], 1);
             // evt.preventDefault();
           }

     // NOTE: firefox only, same es default behavior for chrome
     // abcd[|*abcd] -> abcd*[|abcd]
     if (evt.key === 'ArrowLeft' || evt.key === 'Left')
       if (s.focusNode.parentNode.nodeName === 'SPAN')
         if (s.focusOffset === 1) {
           if (s.focusNode.previousSibling === null)
             r.setStart(s.focusNode.parentNode.previousSibling, s.focusNode.parentNode.previousSibling.nodeValue.length);
         }

     // NOTE: firefox only
     // [abcd]|*abcd -> [abcd*]|abcd
     if (evt.key === 'ArrowLeft' || evt.key === 'Left')
       if (s.focusNode.previousSibling !== null)
         if (s.focusOffset === 1) {
           if (s.focusNode.previousSibling.nodeName === 'SPAN') 
             r.setStart(s.focusNode.previousSibling.lastChild, s.focusNode.previousSibling.lastChild.nodeValue.length);
         }

   }, false);

   abyss.addEventListener('keyup', function (evt) {

     var s = window.getSelection();
     var r = s.getRangeAt(0);

     debug.textContent = JSON.stringify({
       before: before,
       after: {
         path: findPath(r.startContainer),
         node: r.startContainer.nodeName,
         offset: r.startOffset
       }
     }, null, 1);

     // NOTE: with this solution, there is a delay before caret is moved, could use this for dealing with ie11, check if incorrect position first ...
     // if (wasBeforeSpan) {
     //   r.setStart(r.startContainer, 1);
     //   wasBeforeSpan = false;
     // }


   }, false);

 };
</script>
{% endblock %}
