{% extends 'sandbox/base.html' %}
{% load static %}
{% block styles %}
<style>
 body {
   font-family: sans-serif;
 }

 textarea {
   width: 100%;
   height: 240px;
 }

 .background span.a {
   background-color: #ff229c;
 }

 .background span.b {
   background-color: #fe6a78;
 }
 
 .background span.c {
   background-color: #ef9957;
 }

 .background span.d {
   background-color: #e0ca34;
 }

 .background span.e {
   background-color: #c9ff0b;
 }


 .border .content {
   line-height: 1.75em;
 }

 .border span > span {
   padding-bottom: 3px;
 }

 .border span.a {
   border-bottom: 2px solid #ff229c;
 }

 .border span.b {
   border-bottom: 2px solid #fe6a78;
 }
 
 .border span.c {
   border-bottom: 2px solid #ef9957;
 }

 .border span.d {
   border-bottom: 2px solid #e0ca34;
 }

 .border span.e {
   border-bottom: 2px solid #c9ff0b;
 }


 .bracket span.a:before {
   background-color: #ff229c;
 }

 .bracket span.b:before {
   background-color: #fe6a78;
 }
 
 .bracket span.c:before {
   background-color: #ef9957;
 }

 .bracket span.d:before {
   background-color: #e0ca34;
 }

 .bracket span.e:before {
   background-color: #c9ff0b;
 }

 .bracket span:before {
   display: inline-block;
   height: 1em;
   content: '|';
 }

 .bracket span {
   will-change: transform;
 }

</style>
{% endblock %}
{% block body_class_list %}border{% endblock body_class_list %}
{% block content %}
<form class="js-form">
  <label>dom vs js
    <input type="text" class="js-elapsed">
  </label>
  <button name="render">render</button>
  <button name="generate">generate</button>
  &nbsp;
  <label for="renderer">Renderer: </label>
  <select class="js-renderer" id="renderer" name="renderer">
    <option value="text">Text</option>
    <option value="background">Background</option>
    <option value="border" selected>Border</option>
    <option value="bracket">Bracket</option>
  </select>
  &nbsp;
  <label>selected
    <input type="text" class="js-selected">
  </label>
</form>
<div class="content js-content" contenteditable spellcheck="false"></div>
<textarea></textarea>
{% endblock %}
{% block scripts %}
<script src="{% static 'sandbox/js/temp/handlers.js' %}"></script>
<script src="{% static 'sandbox' %}/js/render.js"></script>
<script>
 window.onload = function (evt) {

   var textarea = document.querySelector('textarea');
   var content = document.querySelector('.js-content');
   var elapsed = document.querySelector('.js-elapsed');
   var selected = document.querySelector('.js-selected');
   var form = document.querySelector('.js-form');
   var method = document.querySelector('.js-renderer');

   var RenderClass = null;

   form.addEventListener('click', function (evt) {
     evt.preventDefault();

     var node = evt.target;

     if (node.nodeName === 'BUTTON') {
       if (node.name === 'render')
         actions.render(1);
       else if (node.name === 'generate') {
         actions.generate();
         actions.render(1);
       }
     }

   }, false);

   method.addEventListener('change', function (evt) {

     evt.preventDefault();

     if (evt.cancelable)
       evt.stopPropagation();

     changeRenderer();

   }, false);

   function changeRenderer () {

     var name = method.options[method.selectedIndex].value;

     RenderClass = RENDERERS[name];

     document.body.className = name;
     console.assert(typeof RenderClass === 'function');

     actions.render(1);
   }

   var string = null;
   var segments = null;

   function mustGenerate () {
     return string === null || segments === null;
   }

   var actions = {
     generate: function () {
       var tokens = createTokens(1000);
       string = tokens.join(' ');
       segments = createSegments(string, 2);
       insertLineBreaks(string, segments);
     },
     render: function (n) {

       performance.clearMarks();
       performance.clearMeasures();

       n = n || 1;

       
       if (mustGenerate())
         actions.generate();

       var result;

       performance.mark('start');


       for (var index = 0; index < n; index++) {
         result = renderHTML(
           string,
           segments.sort(compareStartOffset),
           new RenderClass()
         );
       }


       performance.mark('end.js');


       content.innerHTML = result;

       performance.mark('end')


       performance.measure('js', 'start', 'end.js');
       performance.measure('dom', 'end.js', 'end');


       elapsed.value = [
         Math.round(100 * performance.getEntriesByName('dom')[0].duration) / 100,
         Math.round(100 * performance.getEntriesByName('js')[0].duration) / 100
       ].join(' ');


       textarea.value = result;

     }
   };

   changeRenderer();
   actions.generate();
   actions.render();

   document.addEventListener('selectionchange', function (evt) {

     console.count('selectionChangeCallback');

     performance.mark('start.select');



     var s = window.getSelection();
     var r = document.createRange();

     var startNode = findNodeDFS(content, isTextNode);

     r.setStart(startNode, 0);
     r.setEnd(s.focusNode, s.focusOffset);

     var focusOffset = r.toString().length;

     r.setEnd(s.anchorNode, s.anchorOffset);
     var anchorOffset = r.toString().length ;

     var offset = Math.min(anchorOffset, focusOffset);
     var length = Math.max(anchorOffset, focusOffset) - offset;



     performance.mark('end.select');
     performance.measure('select', 'start.select', 'end.select');



     selected.value = [
       offset, length
     ].join(' ');



     var e = performance.getEntriesByName('select');
     // console.log('select', e[e.length - 1].duration);



     // console.log(length);
     // console.log(string.slice(0, length));

       
   }, false);


   function isTextNode (node) { return node.nodeName === '#text'; }

   function findNodeDFS (root, test) {

     var node;
     var result;

     for (var index = 0; index < root.childNodes.length; index++) {

       node = root.childNodes[index];

       if (test(node))
         return node;

       result = findNodeDFS(node, test);

       if (result !== null)
         return result;
     }

     return null;

   }

   observer.observe(content, {
     subtree:true,
     childList: true,
     characterData: true
   });

 };

 var observer = new MutationObserver(function (records) {

   console.count('mutationObserverCallback');

   for (var index = 0; index < records.length; index++) {
     var r = records[index];
     if (r.type === 'characterData') {
       // do something with this ...
       console.log(r);
     }
     else if (r.type === 'childList') {
       console.log(r);
     }
   }
 });

 function renderHTML (string, segments, renderer) {

   render(
     string, segments.sort(compareStartOffset),
     renderer.open, renderer.close,
     renderer.handleText, renderer.openClose
   );

   return renderer.getResult();

 }

 function createSegments (string, count) {

   count = count || 1;

   var segments = [];

   while (count-- > 0) {

     var offset = null;

     for (var index = 0; index < string.length; index++) {

       var flag = test(
         string.charAt(index),
         string.charAt(index + 1),
         string.charAt(index - 1),
         offset !== null
       );

       if (flag) {
         if (offset === null) {
           offset = index;
         }
         else {
           segments.push(new Segment(
             getRandomItem(N), offset, index - offset));
           offset = null;
         }
       }

     }
   }

   return segments;

   function test (char, next, prev, isSegment) {

     if (prev === ' ' || prev === '' || isPunct(prev)) {
       if (isSegment) {
         return Math.random() < 0.25;
       }
       else {
         return Math.random() < 0.75;
       }
     }
     else if (next === ' ' || next === '' || isPunct(next)) {
       if (isSegment) {
         return Math.random() < 0.25;
       }
       else {
         return Math.random() < 0.75;
       }
     }
     else {
       if (isSegment) {
         return Math.random() < 0.1;
       }
       else {
         return Math.random() < 0.25;
       }
     }
   }
 }


 function insertLineBreaks (string, segments, length) {

   var length = length || 80; // line length
   var count = Math.floor(string.length / length)

   var startOffset = 0;
   var endOffset = length;

   for (var index = 0; index < count; index++) {

     var offset = index * length + Math.random() * length;

     // find nearest whitespace
     if (string.indexOf(' ', offset) < index * length + length)
       offset = string.indexOf(' ', offset);

     segments.push(new Segment('br', offset, 0));
   }
   return segments;

 }

 function createTokens (length) {

   var tokens = [];
   var token;

   for (var index = 0; index < length - 1; index++) {

     token = getRandomItem(T);

     if (!isPunct(token) && Math.random() < 0.2) {
       tokens.push(token + getRandomItem(P));
     }

     tokens.push(token);

   }

   return tokens;
 }

 var N = ['a', 'b', 'c', 'd', 'e'];

 var P = ['.', '?', '!'];

 var T = ['moo', 'bark', 'meow', 'purr', 'hiss', 'gobble', 'oink', 'bugle', 'bleat'];

 function isPunct (token) {
   return P.indexOf(token) > -1;
 }

 function getRandomItem (tokens) {
   return tokens[Math.floor(Math.random() * tokens.length)];
 }

</script>
{% endblock %}
