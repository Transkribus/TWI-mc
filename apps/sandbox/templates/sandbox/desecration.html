{% extends 'sandbox/base.html' %}
{% load static %}
{% block styles %}
<style>
 body {
   padding: 0 2em 2em;
   font-family: sans-serif;
 }

 div {
   width: 100%;
   padding: 0.2em;
   line-height: 1.75em;
   border: 1px solid transparent;
   background-color: rgba(0, 0, 0, 0.05);
 }

 div:focus {
   outline: 0;
   border: 1px solid rgba(0, 0, 255, 0.25);
   box-shadow: 0 0 5px rgba(0, 0, 255, 0.25);
   background-color: rgba(0, 0, 255, 0.05);
 }

 textarea {
   width: 100%;
   height: 240px;
 }

 span,
 mark {
   background-color: rgba(0, 255, 0, 0.25);
 }

 .debug {
   margin: 5px 0;
   background-color: rgba(0, 0, 0, 0.05);
 }

 .state {
   background-color: rgba(0, 0, 0, 0.25);
 }

 .state.enabled {
   background-color: rgba(0, 255, 0, 0.25);
 }

 .state.disabled {
   background-color: rgba(255, 0, 0, 0.25);
 }

 .hidden {
   display: none;
 }

 .main {
   display: flex;
   flex-flow: row;
 }

 .example,
 .info {
   padding: 0.5em;
   width: 50%;
 }


</style>
{% endblock %}
{% block content %}
<main class="main">
  <section class="example">
    <div class="desecration js-desecration" spellcheck="false" autocomplete="false" autocapitalize="false" contenteditable>Lorem ipsum dolor sit amet, consectetuer adipiscing elit.<br>Aenean commodo ligula eget dolor. Aenean massa.<br>Cum sociis natoque penatibus et magnis dis parturient montes,<br>nascetur ridiculus mus. Donec quam felis, ultricies nec,<br>pellentesque eu, pretium quis, sem. Nulla consequat massa quis<br>enim. Donec pede justo, fringilla vel, aliquet nec, vulputate<br>eget, arcu. In enim justo, rhoncus ut, imperdiet a, venenatis<br>vitae, justo.<br></div>
  </section>
  <section class="info">
    <div class="states">
      <strong>Actions:</strong>
      <!-- <span class="state state--backspace js-backspace">backspace</span>
           <span class="state state--delete js-delete">delete</span> -->
      <form class="js-actions">
        <button name="tag" value="1" class="js-tag-1">tag 1</button>
        <button name="tag" value="2" class="js-tag-2">tag 2</button>
        <button name="format" value="1" class="js-format-1">format 1</button>
        <button name="format" value="2" class="js-format-2">format 2</button>
      </form>
    </div>
    <div class="debug js-debug">&nbsp;</div>
    <textarea class="js-textarea"></textarea>
  </section>
</main>
{% endblock %}
{% block scripts %}
<script src="{% static 'sandbox' %}/js/polyfills/array-from-polyfill.js"></script>
<script>

 console.assert(document.queryCommandSupported('superscript'));
 console.assert(document.queryCommandSupported('underline'));
 console.assert(document.queryCommandSupported('insertBrOnReturn'));

 document.execCommand('insertBrOnReturn', false, true);

 window.onload = function (evt) {

   var desecration = document.querySelector('.js-desecration');
   var textArea = document.querySelector('.js-textarea');
   var debug = document.querySelector('.js-debug');
   var form = document.querySelector('.js-actions');

   desecration.addEventListener('input', update, false);
   textArea.addEventListener('input', otherUpdate, false);
   form.addEventListener('click', handleAction, false);

   update();

   function update () {
     var string = desecration.innerHTML;
     var token = '<br>';
     var itemList = [];

     var i = 0;
     var j = string.indexOf(token);

     var I = 512;

     // FIXME: does this work if only one line?
     while ((j = string.indexOf(token, i)) >= 0) {

       itemList.push(string.slice(i, j + token.length));

       i = j + token.length;

       I--;
       if (I < 0)
         break;
     }

     textArea.value = itemList.join('\n');
     // textArea.value = desecration.innerHTML;
   }

   function otherUpdate () {
     desecration.outerHTML = textArea.value;
   }

   desecration.addEventListener('paste', gulp, false);
   desecration.addEventListener('cut', gulp, false);
   desecration.addEventListener('copy', gulp, false);

   function gulp (evt) {
     evt.preventDefault();
     if (evt.cancelable)
       evt.stopPropagation();
   }

   desecration.addEventListener('keydown', function (evt) {

     if (evt.key === 'Enter'){
       // evt.preventDefault();
     }

     else if (evt.key === 'Backspace') {
       // evt.preventDefault();
     }

     else if (evt.key === 'Backspace') {
       evt.preventDefault();
     }


     // debug.textContent = r.startContainer.nodeName;

   }, false);

   function print () {

     var s = window.getSelection();
     var r = s.getRangeAt(0);

     var node = s.focusNode;
     var nodeList = [];
     var parentNode = desecration;


     // NOTE: if focus on BR, set it to end of text
     if (s.focusNode === parentNode) {
       var focusNode = s.focusNode.childNodes[s.focusOffset - 1]
       var focusOffset = focusNode.nodeName !== '#text' ? focusNode.childNodes.length : focusNode.nodeValue.length;
       
       s.setBaseAndExtent(focusNode, focusOffset, focusNode, focusOffset);
     }

     while (node !== parentNode) {
       nodeList.unshift(node.nodeName.toLowerCase());
       node = node.parentNode;
     }

     nodeList.unshift(parentNode.nodeName);

     var breakNode = findClosestNode(s.focusNode, function (node) {
       return node.nodeName === 'BR';
     });

     var breakList = Array.from(parentNode.querySelectorAll('br'));
     var breakIndex = breakList.indexOf(breakNode);

     debug.textContent = JSON.stringify({
       line: breakIndex + 1,
       node: s.focusNode.nodeName,
       offset: s.focusOffset,
       path: nodeList.join('.') + '[' + s.focusOffset + ']'
     }, null, 1);

   }

   function findClosestNode (node, test) {

     var result = null;

     while (node.nextSibling !== null) {

       if (test(node.nextSibling))
         return node.nextSibling;

       result = findNodeDFS(node.nextSibling, test);

       if (result !== null)
         return result;

       node = node.nextSibling;
     }

     if (node.parentNode !== null)
       return findClosestNode(node.parentNode, test);

     return null;

   }

   function findNodeDFS (root, test) {

     var node;
     var result;

     for (var index = 0; index < root.childNodes.length; index++) {

       node = root.childNodes[index];

       if (test(node))
         return node;

       result = findNodeDFS(node, test);

       if (result !== null)
         return result;
     }

     return null;

   }

   document.addEventListener('selectionchange', print, false);
   // document.addEventListener('selectionchange', handleSelectionChange, false);

   function handleSelectionChange (evt) {

     var s = window.getSelection();
     var r = s.getRangeAt(0);

     // FIXME: handle selections that are NOT collapsed     
     if (!r.collapsed)
       throw new Error("Range must be collapsed!");

     var node = s.focusNode;

     // TODO: figure out if what state should be

     return;

     // do things

     node = document.querySelector('.js-backspace');

     // if this is zero, do not allow backspace ...
     if (range.compareBoundaryPoints(Range.START_TO_START, r) === 0)
       addOrReplaceClass(node, 'disabled', 'enabled');
     else
       addOrReplaceClass(node, 'enabled', 'disabled');

     node = document.querySelector('.js-delete');

     // if this is zero, do not allow delete ...
     if (range.compareBoundaryPoints(Range.END_TO_END, r) === 0)
       addOrReplaceClass(node, 'disabled', 'enabled');
     else
       addOrReplaceClass(node, 'enabled', 'disabled')       

   }

   function addOrReplaceClass (node, newClassName, oldClassName) {
     if (node.classList.contains(oldClassName))
       node.classList.remove(oldClassName);
     node.classList.add(newClassName);
   }



   function handleAction (evt) {

     evt.preventDefault();

     var name = evt.target.name;

     switch (evt.target.name) {
       case 'tag':
       case 'format':
         wrapWith(evt.target.name, evt.target.value);
         break;
       default:
         console.warn("Invalid case ...");
     }

   }

   var nextTagId = 1;

   function wrapWith (name, value) {

     var s = window.getSelection();
     var r = s.getRangeAt(0);

     // NOTE: behavior should be like this: allow splitting of formatting / decorations, but fail if existing tag would be split

     // FIXME: normalize selection before applying tag, e.g. remove spaces chars before / after, probably has to try different variants of setting start / end, could also lookup tag offset + length to decide whether tag should be appended as child to existing tag or wrap it, etc.

     // FIXME: focus / anchor nodes need fudging, e.g. tagging *[abcd*], [*abcd]* will not work with surroundContents, maybe use setStartBefore / setStartAfter?

     // FIXME: undo does not work when using surroundContents

     // FIXME: do not allow splitting up of existing tags, but do allow splitting up of 

     // FIXME: figure out tagging behavior when tagged with same tag wtwice, e.g. resize existing tag if tag is applied twice

     // FIXME: use insertHTML so undo works ..

     // s.containsNode(node, partialContainment);

     if (name === 'tag') {

       var TAG = {
         NODE: 'span',
         CLASS: 'tag'
       };

       var node = document.createElement(TAG.NODE);
       node.setAttribute('id', nextTagId++);
       node.classList.add(TAG.CLASS, TAG.CLASS + '--' + value);

       // NOTE: fails for partially selected nodes ...

       var useExtractContents = true;
       var useInsertHTML = true;

       if (!useExtractContents)
         try {
           r.surroundContents(node);
         }
         catch (e) {
           console.error(e);
         }
       else { 
         if (!useInsertHTML) {
           node.appendChild(r.extractContents());
           r.insertNode(node);
         }
         else {
           node.appendChild(r.cloneContents());
           document.execCommand('insertHTML', false, node.outerHTML);
         }
       }
     }

     else if (name === 'format') {
       if (value == 1)
         document.execCommand('superscript', false, true);
       else
         document.execCommand('underline', false, true);
     }

     desecration.normalize();

     update();

   }

 };
</script>
{% endblock %}
