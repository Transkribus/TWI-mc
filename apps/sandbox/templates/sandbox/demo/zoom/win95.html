{% extends 'sandbox/base.html' %}
{% load static %}
{% block styles %}
<style>
 * {
   margin: 0;
   padding: 0;
   box-sizing: border-box;
 }

 html, body {
   height: 100%;
 }

 main {
   min-height: 100%;
   background-color: #333;
   text-align: center;
 }

 .loading main .viewport {
   display: none;
 }

 .viewport {
   box-shadow: 2px 2px 8px rgba(0, 0, 0, 0.5);
 }

 body.zooming {
   cursor: zoom-in;
 }

 .menu {
   position: fixed;
   left: 0;
   top: 0;
 }

 .canvas {
   display: none;

   position: fixed;
   left: 0;
   top: 0;

   // background: rgba(127, 255, 127, 0.1);
 }

 .zooming .canvas {
   display: block;
 }

</style>
{% endblock %}
{% block content %}
<main class="js-main">
  <svg class="viewport js-svg" viewBox="0 0 2802 4049" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xmlns:xlink="http://www.w3.org/1999/xlink">
    <image class="image js-image" x="0" y="0" width="100%" height="100%" xlink:href="/static/sandbox/data/page.jpeg"/>
  </svg>
</main>
<canvas class="canvas js-canvas"></canvas>
<aside class="menu">
  <button class="js-zoom" value="zoom">toggle</button>
</aside>
{% endblock %}
{% block scripts %}
<script src="{% static 'sandbox' %}/js/zoom.js"></script>
<script>
 window.addEventListener('load', function (evt) {

   var COLOR = 'rgba(127,255,127,0.25)';

   var isZooming = false;

   var zoomNode = document.querySelector('.js-zoom');
   var mainNode = document.querySelector('.js-main');
   var canvasNode = document.querySelector('.js-canvas');
   var context = canvasNode.getContext('2d');
   var svgNode = document.querySelector('.js-svg');

   var startX = null;
   var startY = null;

   canvasNode.setAttribute('width', mainNode.offsetWidth);
   canvasNode.setAttribute('height', mainNode.offsetHeight);

   context.fillStyle = COLOR;

   zoomNode.addEventListener('click', function (evt) {

     evt.preventDefault();

     if (isZooming)
       return;

     if (document.body.classList.toggle('zooming') === true) {

       if (evt.cancelable)
         evt.stopPropagation();

       setTimeout(addEventListeners, 250);

     }

     else {

       if (evt.cancelable)
         evt.stopPropagation();

       removeEventListeners();

     }

   }, false);

   function addEventListeners () {
     canvasNode.addEventListener('mousedown', startZoom, false);
     // document.documentElement.addEventListener('mousemove', zoom, false);
     canvasNode.addEventListener('mousemove', zoom, false);
     // document.documentElement.addEventListener('mouseup', stopZoom, false);
     canvasNode.addEventListener('mouseup', stopZoom, false);
   }

   function removeEventListeners () {
     canvasNode.removeEventListener('mousedown', startZoom);
     // document.documentElement.removeEventListener('mousemove', zoom);
     canvasNode.removeEventListener('mousemove', zoom);
     // document.documentElement.removeEventListener('mouseup', stopZoom);
     canvasNode.removeEventListener('mouseup', stopZoom);
   }

   function startZoom (evt) {

     console.debug("startZoom", isZooming, {startX: startX, startY: startY});

     evt.preventDefault();

     startX = evt.clientX;
     startY = evt.clientY;

     isZooming = true;

   }

   var deltaX = null;
   var deltaY = null;

   function zoom (evt) {

     console.debug("zoom", isZooming, {startX: startX, startY: startY});

     evt.preventDefault();

     if (!isZooming)
       return;

     if (deltaX !== null || deltaY !== null) {
       context.clearRect(startX, startY, startX + deltaX, startY + deltaY);
     }

     deltaX = evt.clientX - startX;
     deltaY = evt.clientY - startY;

     context.fillRect(startX, startY, deltaX, deltaY);

   }

   function stopZoom (evt) {

     console.debug("stopZoom", isZooming, {startX: startX, startY: startY});

     evt.preventDefault();

     if (!isZooming)
       return;

     deltaX = evt.clientX - startX;
     deltaY = evt.clientY - startY;

     if (deltaX !== null || deltaY !== null)
       context.clearRect(startX, startY, startX + deltaX, startY + deltaY);

     var params = {x: startX, y: startY, width: deltaX, height: deltaY};

     startX = startY = deltaX = deltaY = null;

     isZooming = false;

     onZoomStop(params);

   }

   var imageRect = {
     x: 0,
     y: 0,
     width: 2802,
     height: 4049
   };

   var viewportRect = {
     x: 0,
     y: 0,
     width: mainNode.clientWidth,
     height: mainNode.clientHeight
   };

   function onZoomStop (rect) {

     removeEventListeners();

     document.body.classList.remove('zooming');

     // console.log(rect, imageRect)
     console.log(viewportRect.width / imageRect.width);

     var rect = calcScaledRect(rect, imageRect.width / viewportRect.width);
     // console.log(viewBox);


     var rectNode = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
     rectNode.setAttribute('x', rect.x);
     rectNode.setAttribute('y', rect.y);
     rectNode.setAttribute('width', rect.width);
     rectNode.setAttribute('height', rect.height);
     rectNode.setAttribute('fill', COLOR);
     rectNode.setAttribute('stroke', '#333');


     svgNode.setAttribute('preserveAspectRatio', 'xMinYMin');
     svgNode.setAttribute('viewBox', rectToViewBoxString({
       x: -rect.x, y: -rect.y, width: rect.width, height: rect.height
     }));

     return;

     rectNode.addEventListener('click', function handle (evt) {

       // svgNode.setAttribute('preserveAspectRatio', 'xMaxYMin slice');
       console.log('reft', rect);
       svgNode.setAttribute('preserveAspectRatio', 'xMidYMid slice');
       svgNode.setAttribute('viewBox', rectToViewBoxString({
         x: -rect.x, y: -rect.y, width: rect.width, height: rect.height
       }));
       // svgNode.currentScale = 10;

       evt.target.removeEventListener('click', handle)
       evt.target.parentNode.removeChild(evt.target);
     }, false);

     svgNode.appendChild(rectNode);

   }

   // onZoomStop({x: 0, y: 0, width: 100, height: 100});

 }, false);
</script>
{% endblock %}
